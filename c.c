#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <linux/in.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <malloc.h>

uint64_t get_rip(void) {
	asm("mov 0(%rsp), %rax");
}
extern int errno;

void *end_of_code_ptr;
void *start_of_code_ptr;
uint64_t length_of_code = 0, length_of_code_page = 0;
void *new_code = NULL;
uint64_t hijacked_offset;
uint64_t server_offset;
uint64_t create_server_offset;
uint64_t gadget_offset;
uint64_t read_too_much_offset;
uint64_t write_success_offset;
uint64_t child_server_offset;

void (*new_hijacked)(void) = NULL;
void (*new_server)(int) = NULL;
int (*new_create_server)(void) = NULL;
void (*new_gadget)(void) = NULL;
void (*new_read_too_much)(int) = NULL;
void (*new_write_success)(int) = NULL;
void (*new_child_server)(int) = NULL;

void *main_code_start = NULL;
void *main_code_end = NULL;
uint64_t main_code_length_page = 0;

int create_server(void);
void server(int sock);
void end_of_code(void);
void hijacked(void);
void gadget(void);
void read_too_much(int client);
void write_success(int client);
void child_server(int client);

void *rmemalign(size_t alignment, size_t size, int max) {
	void *ptrs[100] = {NULL,};
	int i = 0;
	void *selected = NULL;

	srand((unsigned int)time(NULL));
	//srand(1);

	if (max == 0 || max > 100) {
		max = 100;
	}
	for (i = 0; i<max; i++) {
		ptrs[i] = (void*)memalign(alignment, size);
		if (ptrs[i] == NULL) {
			selected = (void*)-1;
			break;
		}
	}

	if ((void*)-1 != selected) {
		int index = 0;
		index = rand() % max;
		selected = ptrs[index];
	}

	for (i = 0; i<max; i++)
		if (ptrs[i] != selected)
			free(ptrs[i]);
	return selected;

}

void sighndl(int v) {
	printf("We are in sighandler.\n");
	while (0 < waitpid(-1, NULL, WNOHANG)) { printf("Collected ...\n"); }
}

#define PAGE_SIZE_MASK (0xfffff000)
#define PAGE_SIZE (0x1000)

int main() {
	int fd = -1;
	char a[] = "a";
	char b[] = "b";

	end_of_code();

	main_code_start = (void*)((uint64_t)rmemalign & PAGE_SIZE_MASK);
	main_code_start+=PAGE_SIZE;
	main_code_end = (void*)end_of_code;
	main_code_length_page = (((uint64_t)main_code_end - (uint64_t)main_code_start) & PAGE_SIZE_MASK) + PAGE_SIZE;

	printf("main_code_start: 0x%x\n", main_code_start);
	printf("main_code_length_page: %lu\n", main_code_length_page);

	printf("&hijacked: 0x%x\n", hijacked);
	printf("&gadget: 0x%x\n", gadget);
	signal(SIGCHLD, sighndl);

	fd = create_server();
	if (fd == -1) {
		printf("error: create_server() failed.\n");
		return 1;
	}
	server(fd);

	return strcmp(a,b);
}

int create_server(void) {
	int fd = -1;
	struct sockaddr_in saddr;

	memset(&saddr, 0, sizeof(struct sockaddr_in));
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(6001);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd == -1)
		return fd;
	bind(fd, (struct sockaddr*)&saddr, sizeof(struct sockaddr_in));
	return fd;
}

void read_too_much(int client) {
	char eight_bytes[8];
	char char_read = 0;
	int just_read = 0;
	int i = 0;

	printf("eight_bytes = 0x%x\n", eight_bytes);
	printf("char_read = 0x%x\n", &char_read);
	printf("just_read = 0x%x\n", &just_read);
	printf("client = 0x%x\n", &client);
	printf("i = 0x%x\n", &i);

	memset(eight_bytes, sizeof(char)*4, 0);

	printf("read_too_much!\n");
	while ((0 < (just_read = read(client, &char_read, 1))))// && char_read != '\n') 
	{
		printf("read: %c\n", char_read);
		printf("just_read: %d\n", just_read);
		printf("eight_bytes[%d]: %p\n", i, &(eight_bytes[i]));
		eight_bytes[i++] = char_read;
	}
	printf("(final)read: %c\n", char_read);
	printf("(final)just_read = %d\n", just_read);

	return;
}

void write_success(int client) {
	char *success = "s";
	int wrote = 0;
	if (0 > (wrote = write(client, success, strlen(success))))
	{
		printf("write() failed (%d): %s\n", wrote, strerror(errno));
	}
	return;
}

void server(int sock) {
	int client = 0;
	int child_pid = 0;

	if (-1 == listen(sock, 0)) {
		printf("listen() failed. Stopping.");
		shutdown(sock, SHUT_RDWR);
		close(sock);
		_exit(1);
	}

	for (;;) {
		if (0 > (client = accept(sock, NULL, NULL))) {
			printf("accept() failed. Stopping.");
			shutdown(sock, SHUT_RDWR);
			close(sock);
			_exit(1);
		}
		if (0 == (child_pid = fork())) {
			close(sock);

	new_code = rmemalign(PAGE_SIZE, length_of_code_page, 0);
	//new_code = memalign(PAGE_SIZE, length_of_code_page);

	end_of_code_ptr = (void*)end_of_code;
	start_of_code_ptr = (void*)create_server;
	length_of_code = (uint64_t)end_of_code_ptr - (uint64_t)start_of_code_ptr;
	length_of_code_page = (length_of_code & PAGE_SIZE_MASK) + PAGE_SIZE;

	printf("end_of_code_ptr: %x\n", end_of_code_ptr);
	printf("start_of_code_ptr: %x\n", start_of_code_ptr);
	printf("length_of_code: %lu\n", length_of_code);
	printf("length_of_code (to page): %lu\n", length_of_code_page);
	printf("new_code: 0x%x\n", new_code);

	memcpy(new_code, start_of_code_ptr, length_of_code);
	mprotect(new_code, length_of_code_page, PROT_READ|PROT_EXEC);

	hijacked_offset = (uint64_t)
		((uint64_t)hijacked - (uint64_t)start_of_code_ptr);
	server_offset = (uint64_t)
		((uint64_t)server - (uint64_t)start_of_code_ptr);
	create_server_offset = (uint64_t)
		((uint64_t)create_server- (uint64_t)start_of_code_ptr);
	gadget_offset = (uint64_t)
		((uint64_t)gadget - (uint64_t)start_of_code_ptr);
	read_too_much_offset = (uint64_t)
		((uint64_t)read_too_much - (uint64_t)start_of_code_ptr);
	write_success_offset = (uint64_t)
		((uint64_t)write_success - (uint64_t)start_of_code_ptr);
	child_server_offset = (uint64_t)
		((uint64_t)child_server - (uint64_t)start_of_code_ptr);

	new_hijacked = (void (*)(void))
		((uint64_t)new_code + hijacked_offset);
	new_server = (void (*)(int))
		((uint64_t)new_code + server_offset);
	new_create_server = (int (*)(void))
		((uint64_t)new_code + create_server_offset);
	new_gadget = (void (*)(void))
		((uint64_t)new_code + gadget_offset);
	new_read_too_much = (void (*)(int))
		((uint64_t)new_code + read_too_much_offset);
	new_write_success = (void (*)(int))
		((uint64_t)new_code + write_success_offset);
	new_child_server = (void (*)(int))
		((uint64_t)new_code + child_server_offset);

#if 0
	printf("accept client: %p\n", &client);
	printf("accept client: %d\n", client);
	new_read_too_much(client);
	printf("post-read client: %d\n", client);
	new_write_success(client);
	close(client);
	shutdown(client, SHUT_RDWR);
	printf("Shutting down client.\n");
	_exit(0);
#else
	new_child_server(client);
#endif

		}
		close(client);
	}
}

void child_server(int client) {
	mprotect(main_code_start, main_code_length_page, PROT_READ);
	printf("accept client: %p\n", &client);
	printf("accept client: %d\n", client);
	new_read_too_much(client);
	printf("post-read client: %d\n", client);
	new_write_success(client);
	close(client);
	shutdown(client, SHUT_RDWR);
	printf("Shutting down client.\n");
	_exit(0);
}

void hijacked(void) {
	printf("hijacked!\n");
	while (1) {}
	return;
}

void gadget(void) {
	int i = 0;
	asm("pop %%rbx\n"
	    "pop %%rbp\n"
	    "pop %%r12\n"
	    "pop %%r13\n"
	    "pop %%r14\n"
	    "pop %%r15\n"
	    "ret\n"
			:
			:
			:);
	for (i=0; i<15; i++) {
		asm("pop %r15\n");
	}
	asm("pop %rax\n");
	asm("ret\n");
	asm("syscall\n");
}

void end_of_code(void) {
	int i = 0;
	return;
}
