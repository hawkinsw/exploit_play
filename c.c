#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <linux/in.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <stdint.h>

extern int errno;

#ifdef STACK_PROTECTOR
#define FORCE_STACK_PROTECTOR char buffer[400];
uint64_t get_canary(void) {
	asm("mov %%fs:0x28, %%rax\n"
	    :
	    :
	    :);
}

uint64_t set_canary(uint64_t new_canary) {
	uint64_t old_canary;
	asm volatile ("mov %%fs:0x28, %0\n"
	    "mov %1, %%fs:0x28\n"
	    : "+r" (old_canary)
	    : "r" (new_canary)
	    :);
	return old_canary;
}

int canary_counter = 0;
#else
#define FORCE_STACK_PROTECTOR ;
#endif

int create_server(void) {
	int fd = -1;
	struct sockaddr_in saddr;

	memset(&saddr, 0, sizeof(struct sockaddr_in));
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(6001);

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd == -1)
		return fd;
	bind(fd, (struct sockaddr*)&saddr, sizeof(struct sockaddr_in));
	return fd;
}

void sighndl(int v) {
	printf("We are in sighandler.\n");
	while (0 < waitpid(-1, NULL, WNOHANG)) { printf("Collected ...\n"); }
}

void read_too_much(int client) {
	char eight_bytes[8];
	char char_read = 0;
	int just_read = 0;
	int i = 0;
	printf("eight_bytes = 0x%x\n", eight_bytes);
	printf("char_read = 0x%x\n", &char_read);
	printf("just_read = 0x%x\n", &just_read);
	printf("client = 0x%x\n", &client);
	printf("i = 0x%x\n", &i);

	memset(eight_bytes, sizeof(char)*4, 0);

	printf("read_too_much!\n");
	while ((0 < (just_read = read(client, &char_read, 1))))// && char_read != '\n') 
	{
		printf("read: %c\n", char_read);
		printf("just_read: %d\n", just_read);
		printf("eight_bytes[%d]: %p\n", i, &(eight_bytes[i]));
		eight_bytes[i++] = char_read;
	}
	printf("(final)read: %c\n", char_read);
	printf("(final)just_read = %d\n", just_read);

	return;
}

void write_success(int client) {
	FORCE_STACK_PROTECTOR
	char *success = "s";
	int wrote = 0;
	if (0 > (wrote = write(client, success, strlen(success))))
	{
		printf("write() failed (%d): %s\n", wrote, strerror(errno));
	}
	return;
}

void server(int sock) {
	int client = 0;
	int child_pid = 0;

	if (-1 == listen(sock, 0)) {
		printf("listen() failed. Stopping.");
		shutdown(sock, SHUT_RDWR);
		close(sock);
		_exit(1);
	}
	for (;;) {
		if (0 > (client = accept(sock, NULL, NULL))) {
			printf("accept() failed. Stopping.");
			shutdown(sock, SHUT_RDWR);
			close(sock);
			_exit(1);
		}
#ifdef STACK_PROTECTOR
		canary_counter++;
#endif
		if (0 == (child_pid = fork())) {
			close(sock);
			handle_child(client);
			_exit(0);
		}
		close(client);
	}
}

void handle_child(int client) {
	FORCE_STACK_PROTECTOR

#ifdef STACK_PROTECTOR
	uint64_t old_canary;
	uint64_t canary;
	old_canary = set_canary(canary_counter);
	canary = get_canary();

	printf("Canary: 0x%x\n", canary);
#endif

	printf("accept client: %p\n", &client);
	printf("accept client: %d\n", client);
	read_too_much(client);
	printf("post-read client: %d\n", client);
	write_success(client);
	close(client);
	shutdown(client, SHUT_RDWR);
	printf("Shutting down client.\n");

#ifdef STACK_PROTECTOR
	set_canary(old_canary);
#endif
	return;
}

void hijacked(void) {
	printf("hijacked!\n");
	while (1) {}
	return;
}

void gadget(void) {
	int i = 0;
	asm("pop %%rbx\n"
	    "pop %%rbp\n"
	    "pop %%r12\n"
	    "pop %%r13\n"
	    "pop %%r14\n"
	    "pop %%r15\n"
	    "ret\n"
			:
			:
			:);
	for (i=0; i<15; i++) {
		asm("pop %r15\n");
	}
	asm("pop %rax\n");
	asm("ret\n");
	asm("syscall\n");
}

int main() {
	int fd = -1;
	char a[] = "a";
	char b[] = "b";

	printf("&hijacked: 0x%x\n", hijacked);
	printf("&gadget: 0x%x\n", gadget);

	signal(SIGCHLD, sighndl);

	fd = create_server();
	if (fd == -1) {
		printf("error: create_server() failed.\n");
		return 1;
	}
	server(fd);

	return strcmp(a,b);
}
